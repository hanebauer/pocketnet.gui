{"version":3,"file":"118.chunk.js?v=7692","mappings":"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","sources":["webpack://peertube-client/./src/assets/player/webtorrent/video-renderer.ts","webpack://peertube-client/./src/assets/player/webtorrent/peertube-chunk-store.ts","webpack://peertube-client/./src/assets/player/webtorrent/webtorrent-plugin.ts","webpack://peertube-client/./src/shims/http.ts","webpack://peertube-client/./src/shims/https.ts","webpack://peertube-client/./src/shims/noop.ts","webpack://peertube-client/./src/shims/stream.ts"],"sourcesContent":["// Thanks: https://github.com/feross/render-media\n// TODO: use render-media once https://github.com/feross/render-media/issues/32 is fixed\n\nconst MediaElementWrapper = require('mediasource')\nimport { extname } from 'path'\nconst videostream = require('videostream')\n\nconst VIDEOSTREAM_EXTS = [\n  '.m4a',\n  '.m4v',\n  '.mp4'\n]\n\ntype RenderMediaOptions = {\n  controls: boolean\n  autoplay: boolean\n}\n\nfunction renderVideo (\n  file: any,\n  elem: HTMLVideoElement,\n  opts: RenderMediaOptions,\n  callback: (err: Error, renderer: any) => void\n) {\n  validateFile(file)\n\n  return renderMedia(file, elem, opts, callback)\n}\n\nfunction renderMedia (file: any, elem: HTMLVideoElement, opts: RenderMediaOptions, callback: (err: Error, renderer?: any) => void) {\n  const extension = extname(file.name).toLowerCase()\n  let preparedElem: any\n  let currentTime = 0\n  let renderer: any\n\n  try {\n    if (VIDEOSTREAM_EXTS.indexOf(extension) >= 0) {\n      renderer = useVideostream()\n    } else {\n      renderer = useMediaSource()\n    }\n  } catch (err) {\n    return callback(err)\n  }\n\n  function useVideostream () {\n    prepareElem()\n\n\n    preparedElem.addEventListener('error', function onError (err: Error) {\n      preparedElem.removeEventListener('error', onError)\n\n      return callback(err)\n    })\n\n\n    preparedElem.addEventListener('loadedmetadata', onLoadStart)\n    return new videostream(file, preparedElem)\n  }\n\n  function useMediaSource (useVP9 = false) {\n    const codecs = getCodec(file.name, useVP9)\n\n\n    prepareElem()\n    preparedElem.addEventListener('error', function onError (err: Error) {\n      preparedElem.removeEventListener('error', onError)\n\n      // Try with vp9 before returning an error\n      if (codecs.indexOf('vp8') !== -1) return fallbackToMediaSource(true)\n\n      return callback(err)\n    })\n    preparedElem.addEventListener('loadedmetadata', onLoadStart)\n\n    const wrapper = new MediaElementWrapper(preparedElem)\n    const writable = wrapper.createWriteStream(codecs)\n    file.createReadStream().pipe(writable)\n\n    if (currentTime) preparedElem.currentTime = currentTime\n\n    return wrapper\n  }\n\n  function fallbackToMediaSource (useVP9 = false) {\n    if (useVP9 === true) console.log('Falling back to media source with VP9 enabled.')\n    else console.log('Falling back to media source..')\n\n    useMediaSource(useVP9)\n  }\n\n  function prepareElem () {\n    if (preparedElem === undefined) {\n      preparedElem = elem\n\n      preparedElem.addEventListener('progress', function () {\n        currentTime = elem.currentTime\n      })\n    }\n  }\n\n  function onLoadStart () {\n    preparedElem.removeEventListener('loadedmetadata', onLoadStart)\n\n\n    if (opts.autoplay) preparedElem.play()\n\n    callback(null, renderer)\n  }\n}\n\nfunction validateFile (file: any) {\n  if (file == null) {\n    throw new Error('file cannot be null or undefined')\n  }\n  if (typeof file.name !== 'string') {\n    throw new Error('missing or invalid file.name property')\n  }\n  if (typeof file.createReadStream !== 'function') {\n    throw new Error('missing or invalid file.createReadStream property')\n  }\n}\n\nfunction getCodec (name: string, useVP9 = false) {\n  const ext = extname(name).toLowerCase()\n  if (ext === '.mp4') {\n    return 'video/mp4; codecs=\"avc1.640029, mp4a.40.5\"'\n  }\n\n  if (ext === '.webm') {\n    if (useVP9 === true) return 'video/webm; codecs=\"vp9, opus\"'\n\n    return 'video/webm; codecs=\"vp8, vorbis\"'\n  }\n\n  return undefined\n}\n\nexport {\n  renderVideo\n}\n","// From https://github.com/MinEduTDF/idb-chunk-store\n// We use temporary IndexDB (all data are removed on destroy) to avoid RAM issues\n// Thanks @santiagogil and @Feross\n\nimport { EventEmitter } from 'events'\nimport Dexie from 'dexie'\n\nclass ChunkDatabase extends Dexie {\n  chunks: Dexie.Table<{ id: number, buf: Buffer }, number>\n\n  constructor (dbname: string) {\n    super(dbname)\n\n    this.version(1).stores({\n      chunks: 'id'\n    })\n  }\n}\n\nclass ExpirationDatabase extends Dexie {\n  databases: Dexie.Table<{ name: string, expiration: number }, number>\n\n  constructor () {\n    super('webtorrent-expiration')\n\n    this.version(1).stores({\n      databases: 'name,expiration'\n    })\n  }\n}\n\nexport class PeertubeChunkStore extends EventEmitter {\n  private static readonly BUFFERING_PUT_MS = 1000\n  private static readonly CLEANER_INTERVAL_MS = 1000 * 60 // 1 minute\n  private static readonly CLEANER_EXPIRATION_MS = 1000 * 60 * 5 // 5 minutes\n\n  chunkLength: number\n\n  private pendingPut: { id: number, buf: Buffer, cb: Function }[] = []\n  // If the store is full\n  private memoryChunks: { [ id: number ]: Buffer | true } = {}\n  private databaseName: string\n  private putBulkTimeout: any\n  private cleanerInterval: any\n  private db: ChunkDatabase\n  private expirationDB: ExpirationDatabase\n  private readonly length: number\n  private readonly lastChunkLength: number\n  private readonly lastChunkIndex: number\n\n  constructor (chunkLength: number, opts: any) {\n    super()\n\n    this.databaseName = 'webtorrent-chunks-'\n\n    if (!opts) opts = {}\n    if (opts.torrent && opts.torrent.infoHash) this.databaseName += opts.torrent.infoHash\n    else this.databaseName += '-default'\n\n    this.setMaxListeners(100)\n\n    this.chunkLength = Number(chunkLength)\n    if (!this.chunkLength) throw new Error('First argument must be a chunk length')\n\n    this.length = Number(opts.length) || Infinity\n\n    if (this.length !== Infinity) {\n      this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength\n      this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1\n    }\n\n    this.db = new ChunkDatabase(this.databaseName)\n    // Track databases that expired\n    this.expirationDB = new ExpirationDatabase()\n\n    this.runCleaner()\n  }\n\n  put (index: number, buf: Buffer, cb: (err?: Error) => void) {\n    const isLastChunk = (index === this.lastChunkIndex)\n    if (isLastChunk && buf.length !== this.lastChunkLength) {\n      return this.nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))\n    }\n    if (!isLastChunk && buf.length !== this.chunkLength) {\n      return this.nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))\n    }\n\n    // Specify we have this chunk\n    this.memoryChunks[index] = true\n\n    // Add it to the pending put\n    this.pendingPut.push({ id: index, buf, cb })\n    // If it's already planned, return\n    if (this.putBulkTimeout) return\n\n    // Plan a future bulk insert\n    this.putBulkTimeout = setTimeout(async () => {\n      const processing = this.pendingPut\n      this.pendingPut = []\n      this.putBulkTimeout = undefined\n\n      try {\n        await this.db.transaction('rw', this.db.chunks, () => {\n          return this.db.chunks.bulkPut(processing.map(p => ({ id: p.id, buf: p.buf })))\n        })\n      } catch (err) {\n        console.log('Cannot bulk insert chunks. Store them in memory.', { err })\n\n        processing.forEach(p => this.memoryChunks[ p.id ] = p.buf)\n      } finally {\n        processing.forEach(p => p.cb())\n      }\n    }, PeertubeChunkStore.BUFFERING_PUT_MS)\n  }\n\n  get (index: number, opts: any, cb: (err?: Error, buf?: Buffer) => void): void {\n    if (typeof opts === 'function') return this.get(index, null, opts)\n\n    // IndexDB could be slow, use our memory index first\n    const memoryChunk = this.memoryChunks[index]\n    if (memoryChunk === undefined) {\n      const err = new Error('Chunk not found') as any\n      err['notFound'] = true\n\n      return process.nextTick(() => cb(err))\n    }\n\n    // Chunk in memory\n    if (memoryChunk !== true) return cb(null, memoryChunk)\n\n    // Chunk in store\n    this.db.transaction('r', this.db.chunks, async () => {\n      const result = await this.db.chunks.get({ id: index })\n      if (result === undefined) return cb(null, Buffer.alloc(0))\n\n      const buf = result.buf\n      if (!opts) return this.nextTick(cb, null, buf)\n\n      const offset = opts.offset || 0\n      const len = opts.length || (buf.length - offset)\n      return cb(null, buf.slice(offset, len + offset))\n    })\n    .catch(err => {\n      console.error(err)\n      return cb(err)\n    })\n  }\n\n  close (cb: (err?: Error) => void) {\n    return this.destroy(cb)\n  }\n\n  async destroy (cb: (err?: Error) => void) {\n    try {\n      if (this.pendingPut) {\n        clearTimeout(this.putBulkTimeout)\n        this.pendingPut = null\n      }\n      if (this.cleanerInterval) {\n        clearInterval(this.cleanerInterval)\n        this.cleanerInterval = null\n      }\n\n      if (this.db) {\n        this.db.close()\n\n        await this.dropDatabase(this.databaseName)\n      }\n\n      if (this.expirationDB) {\n        this.expirationDB.close()\n        this.expirationDB = null\n      }\n\n      return cb()\n    } catch (err) {\n      console.error('Cannot destroy peertube chunk store.', err)\n      return cb(err)\n    }\n  }\n\n  private runCleaner () {\n    this.checkExpiration()\n\n    this.cleanerInterval = setInterval(async () => {\n      this.checkExpiration()\n    }, PeertubeChunkStore.CLEANER_INTERVAL_MS)\n  }\n\n  private async checkExpiration () {\n    let databasesToDeleteInfo: { name: string }[] = []\n\n    try {\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, async () => {\n        // Update our database expiration since we are alive\n        await this.expirationDB.databases.put({\n          name: this.databaseName,\n          expiration: new Date().getTime() + PeertubeChunkStore.CLEANER_EXPIRATION_MS\n        })\n\n        const now = new Date().getTime()\n        databasesToDeleteInfo = await this.expirationDB.databases.where('expiration').below(now).toArray()\n      })\n    } catch (err) {\n      console.error('Cannot update expiration of fetch expired databases.', err)\n    }\n\n    for (const databaseToDeleteInfo of databasesToDeleteInfo) {\n      await this.dropDatabase(databaseToDeleteInfo.name)\n    }\n  }\n\n  private async dropDatabase (databaseName: string) {\n    const dbToDelete = new ChunkDatabase(databaseName)\n    console.log('Destroying IndexDB database %s.', databaseName)\n\n    try {\n      await dbToDelete.delete()\n\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, () => {\n        return this.expirationDB.databases.where({ name: databaseName }).delete()\n      })\n    } catch (err) {\n      console.error('Cannot delete %s.', databaseName, err)\n    }\n  }\n\n  private nextTick <T> (cb: (err?: Error, val?: T) => void, err: Error, val?: T) {\n    process.nextTick(() => cb(err, val), undefined)\n  }\n}\n","import videojs from 'video.js'\nimport * as WebTorrent from 'webtorrent'\nimport { renderVideo } from './video-renderer'\nimport { LoadedQualityData, PlayerNetworkInfo, WebtorrentPluginOptions } from '../peertube-videojs-typings'\nimport { getRtcConfig, timeToInt, videoFileMaxByResolution, videoFileMinByResolution, isIOS, isSafari } from '../utils'\nimport { PeertubeChunkStore } from './peertube-chunk-store'\nimport {\n  getAverageBandwidthInStore,\n  getStoredMute,\n  getStoredP2PEnabled,\n  getStoredVolume,\n  saveAverageBandwidth\n} from '../peertube-player-local-storage'\nimport { VideoFile } from '@shared/models'\n\nconst CacheChunkStore = require('cache-chunk-store')\n\ntype PlayOptions = {\n  forcePlay?: boolean,\n  seek?: number,\n  delay?: number\n}\n\nconst Plugin = videojs.getPlugin('plugin')\n\nclass WebTorrentPlugin extends Plugin {\n  readonly videoFiles: VideoFile[]\n\n  private readonly playerElement: HTMLVideoElement\n\n  private readonly autoplay: boolean = false\n  private readonly startTime: number = 0\n  private readonly savePlayerSrcFunction: videojs.Player['src']\n  private readonly videoDuration: number\n  private readonly CONSTANTS = {\n    INFO_SCHEDULER: 1000, // Don't change this\n    AUTO_QUALITY_SCHEDULER: 3000, // Check quality every 3 seconds\n    AUTO_QUALITY_THRESHOLD_PERCENT: 30, // Bandwidth should be 30% more important than a resolution bitrate to change to it\n    AUTO_QUALITY_OBSERVATION_TIME: 10000, // Wait 10 seconds after having change the resolution before another check\n    AUTO_QUALITY_HIGHER_RESOLUTION_DELAY: 5000, // Buffering higher resolution during 5 seconds\n    BANDWIDTH_AVERAGE_NUMBER_OF_VALUES: 5 // Last 5 seconds to build average bandwidth\n  }\n\n  private readonly webtorrent = new WebTorrent({\n    tracker: {\n      rtcConfig: getRtcConfig()\n    },\n    dht: false\n  })\n\n  private currentVideoFile: VideoFile\n  private torrent: WebTorrent.Torrent\n\n  private renderer: any\n  private fakeRenderer: any\n  private destroyingFakeRenderer = false\n\n  private autoResolution = true\n  private autoResolutionPossible = true\n  private isAutoResolutionObservation = false\n  private playerRefusedP2P = false\n\n  private torrentInfoInterval: any\n  private autoQualityInterval: any\n  private addTorrentDelay: any\n  private qualityObservationTimer: any\n  private runAutoQualitySchedulerTimer: any\n\n  private downloadSpeeds: number[] = []\n\n  constructor (player: videojs.Player, options?: WebtorrentPluginOptions) {\n    super(player)\n\n    this.startTime = timeToInt(options.startTime)\n\n    // Disable auto play on iOS\n    this.autoplay = options.autoplay\n    this.playerRefusedP2P = !getStoredP2PEnabled()\n\n    this.videoFiles = options.videoFiles\n    this.videoDuration = options.videoDuration\n\n    this.savePlayerSrcFunction = this.player.src\n    this.playerElement = options.playerElement\n\n    this.player.ready(() => {\n      const playerOptions = this.player.options_\n\n      /*const volume = getStoredVolume()\n      if (volume !== undefined) this.player.volume(volume)\n\n      const muted = playerOptions.muted !== undefined ? playerOptions.muted : getStoredMute()\n      if (muted !== undefined) this.player.muted(muted)*/\n\n      this.player.duration(options.videoDuration)\n\n      this.initializePlayer()\n      this.runTorrentInfoScheduler()\n\n      this.player.one('play', () => {\n        // Don't run immediately scheduler, wait some seconds the TCP connections are made\n        this.runAutoQualitySchedulerTimer = setTimeout(() => this.runAutoQualityScheduler(), this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\n      })\n    })\n  }\n\n  dispose () {\n    clearTimeout(this.addTorrentDelay)\n    clearTimeout(this.qualityObservationTimer)\n    clearTimeout(this.runAutoQualitySchedulerTimer)\n\n    clearInterval(this.torrentInfoInterval)\n    clearInterval(this.autoQualityInterval)\n\n    // Don't need to destroy renderer, video player will be destroyed\n    this.flushVideoFile(this.currentVideoFile, false)\n\n    this.destroyFakeRenderer()\n  }\n\n  getCurrentResolutionId () {\n    return this.currentVideoFile ? this.currentVideoFile.resolution.id : -1\n  }\n\n  updateVideoFile (\n    videoFile?: VideoFile,\n    options: {\n      forcePlay?: boolean,\n      seek?: number,\n      delay?: number\n    } = {},\n    done: () => void = () => { /* empty */ }\n  ) {\n    // Automatically choose the adapted video file\n    if (!videoFile) {\n      const savedAverageBandwidth = getAverageBandwidthInStore()\n      videoFile = savedAverageBandwidth\n        ? this.getAppropriateFile(savedAverageBandwidth)\n        : this.pickAverageVideoFile()\n    }\n\n    if (!videoFile) {\n      \n      throw Error(`Can't update video file since videoFile is undefined.`)\n\n      /*\n\n      const error: { message: string, code?: number } = {\n        message: \"Can't update video file since videoFile is undefined.\"\n      }\n\n      this.player.tech(true).error = () => error as any\n      this.player.tech(true).trigger('error')\n\n      return\n\n\n      */\n    }\n\n    // Don't add the same video file once again\n    if (this.currentVideoFile !== undefined && this.currentVideoFile.magnetUri === videoFile.magnetUri) {\n      return\n    }\n\n    // Do not display error to user because we will have multiple fallback\n    this.disableErrorDisplay();\n\n    // Hack to \"simulate\" src link in video.js >= 6\n    // Without this, we can't play the video after pausing it\n    // https://github.com/videojs/video.js/blob/master/src/js/player.js#L1633\n    (this.player as any).src = () => true\n    const oldPlaybackRate = this.player.playbackRate()\n\n    const previousVideoFile = this.currentVideoFile\n    this.currentVideoFile = videoFile\n\n    // Don't try on iOS that does not support MediaSource\n    // Or don't use P2P if webtorrent is disabled\n    if (isIOS() || this.playerRefusedP2P) {\n      return this.fallbackToHttp(options, () => {\n        this.player.playbackRate(oldPlaybackRate)\n        return done()\n      })\n    }\n\n\n    this.addTorrent(this.currentVideoFile.magnetUri, previousVideoFile, options, () => {\n      this.player.playbackRate(oldPlaybackRate)\n      return done()\n    })\n\n    this.changeQuality()\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.currentVideoFile.resolution.id })\n  }\n\n  updateResolution (resolutionId: number, delay = 0) {\n    // Remember player state\n    const currentTime = this.player.currentTime()\n    const isPaused = this.player.paused()\n\n    // Hide bigPlayButton\n    if (!isPaused) {\n      this.player.bigPlayButton.hide()\n    }\n\n    // Audio-only (resolutionId === 0) gets special treatment\n    if (resolutionId === 0) {\n      // Audio-only: show poster, do not auto-hide controls\n      this.player.addClass('vjs-playing-audio-only-content')\n      this.player.posterImage.show()\n    } else {\n      // Hide poster to have black background\n      this.player.removeClass('vjs-playing-audio-only-content')\n      this.player.posterImage.hide()\n    }\n\n    const newVideoFile = this.videoFiles.find(f => f.resolution.id === resolutionId)\n    const options = {\n      forcePlay: false,\n      delay,\n      seek: currentTime + (delay / 1000)\n    }\n\n    this.updateVideoFile(newVideoFile, options)\n  }\n\n  flushVideoFile (videoFile: VideoFile, destroyRenderer = true) {\n    if (videoFile !== undefined && this.webtorrent.get(videoFile.magnetUri)) {\n      if (destroyRenderer === true && this.renderer && this.renderer.destroy) this.renderer.destroy()\n\n      this.webtorrent.remove(videoFile.magnetUri)\n    }\n  }\n\n  enableAutoResolution () {\n    this.autoResolution = true\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.getCurrentResolutionId() })\n  }\n\n  disableAutoResolution (forbid = false) {\n    if (forbid === true) this.autoResolutionPossible = false\n\n    this.autoResolution = false\n    this.trigger('autoResolutionChange', { possible: this.autoResolutionPossible })\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.getCurrentResolutionId() })\n  }\n\n  isAutoResolutionPossible () {\n    return this.autoResolutionPossible\n  }\n\n  getTorrent () {\n    return this.torrent\n  }\n\n  getCurrentVideoFile () {\n    return this.currentVideoFile\n  }\n\n  private addTorrent (\n    magnetOrTorrentUrl: string,\n    previousVideoFile: VideoFile,\n    options: PlayOptions,\n    done: Function\n  ) {\n    if (!magnetOrTorrentUrl) return this.fallbackToHttp(options, done)\n\n    const oldTorrent = this.torrent\n    const torrentOptions = {\n      // Don't use arrow function: it breaks webtorrent (that uses `new` keyword)\n      store: function (chunkLength: number, storeOpts: any) {\n        return new CacheChunkStore(new PeertubeChunkStore(chunkLength, storeOpts), {\n          max: 100\n        })\n      }\n    }\n\n    this.torrent = this.webtorrent.add(magnetOrTorrentUrl, torrentOptions, torrent => {\n      if (oldTorrent) {\n        // Pause the old torrent\n        this.stopTorrent(oldTorrent)\n\n        // We use a fake renderer so we download correct pieces of the next file\n        if(options.delay) \n          this.renderFileInFakeElement(torrent.files[ 0 ], options.delay)\n      }\n\n      // Render the video in a few seconds? (on resolution change for example, we wait some seconds of the new video resolution)\n      this.addTorrentDelay = setTimeout(() => {\n\n        // We don't need the fake renderer anymore\n        this.destroyFakeRenderer()\n\n        const paused = this.player.paused()\n\n        this.flushVideoFile(previousVideoFile)\n\n        // Update progress bar (just for the UI), do not wait rendering\n        if (options.seek) this.player.currentTime(options.seek)\n\n        const renderVideoOptions = { autoplay: false, controls: true }\n        renderVideo(torrent.files[ 0 ], this.playerElement, renderVideoOptions, (err, renderer) => {\n          this.renderer = renderer\n\n          if (err) return this.fallbackToHttp(options, done)\n\n          //this.playerElement.play()\n\n          setTimeout(() => {\n            return this.tryToPlay(err => {\n\n              if (err) return done(err)\n  \n              if (options.seek) this.seek(options.seek)\n              if (options.forcePlay === false && paused === true) this.player.pause()\n  \n              return done()\n            })\n          }, 10)\n         \n        })\n      }, options.delay || 0)\n    })\n\n    this.torrent.on('error', (err: any) => console.error(err))\n\n    this.torrent.on('warning', (err: any) => {\n\n      //// TEMP, TO DO\n\n      /*if (err.message.indexOf('Error connecting to wss') !== -1 || err.message.indexOf('Unsupported tracker protocol') !== -1) {\n        this.fallbackToHttp(options, done)\n        return\n      }*/\n\n      // We don't support HTTP tracker but we don't care -> we use the web socket tracker\n      if (err.message.indexOf('Unsupported tracker protocol') !== -1) return\n\n      // Users don't care about issues with WebRTC, but developers do so log it in the console\n      if (err.message.indexOf('Ice connection failed') !== -1) {\n        console.log(err)\n        return\n      }\n\n      // Magnet hash is not up to date with the torrent file, add directly the torrent file\n      if (err.message.indexOf('incorrect info hash') !== -1) {\n        console.error('Incorrect info hash detected, falling back to torrent file.')\n        const newOptions = { forcePlay: true, seek: options.seek }\n        return this.addTorrent(this.torrent[ 'xs' ], previousVideoFile, newOptions, done)\n      }\n\n      // Remote instance is down\n      if (err.message.indexOf('from xs param') !== -1) {\n        this.handleError(err)\n      }\n\n    })\n  }\n\n  private tryToPlay (done?: (err?: Error) => void) {\n\n    if (!done) done = function () {}\n\n    const playPromise = this.player.play()\n\n    if (playPromise !== undefined) {\n\n      return playPromise.then(() => done()).catch((err: Error) => {\n          if (err.message.indexOf('The play() request') !== -1) {\n            return\n          }\n\n          console.log(\"PAUSE\")\n          this.player.pause()\n          this.player.posterImage.show()\n          this.player.removeClass('vjs-has-autoplay')\n          this.player.removeClass('vjs-has-big-play-button-clicked')\n          this.player.removeClass('vjs-playing-audio-only-content')\n\n          return done()\n        })\n    }\n\n    return done()\n\n    \n  }\n\n  private seek (time: number) {\n    this.player.currentTime(time)\n    this.player.handleTechSeeked_()\n  }\n\n  private getAppropriateFile (averageDownloadSpeed?: number): VideoFile {\n    if (this.videoFiles === undefined) return undefined\n\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\n\n    if (files.length === 0) return undefined\n    if (files.length === 1) return files[0]\n\n    // Don't change the torrent if the player ended\n    if (this.torrent && this.torrent.progress === 1 && this.player.ended()) return this.currentVideoFile\n\n    if (!averageDownloadSpeed) averageDownloadSpeed = this.getAndSaveActualDownloadSpeed()\n\n    // Limit resolution according to player height\n    const playerHeight = this.playerElement.offsetHeight\n\n    // We take the first resolution just above the player height\n    // Example: player height is 530px, we want the 720p file instead of 480p\n    let maxResolution = files[0].resolution.id\n    for (let i = files.length - 1; i >= 0; i--) {\n      const resolutionId = files[i].resolution.id\n      if (resolutionId !== 0 && resolutionId >= playerHeight) {\n        maxResolution = resolutionId\n        break\n      }\n    }\n\n    // Filter videos we can play according to our screen resolution and bandwidth\n    const filteredFiles = files.filter(f => f.resolution.id <= maxResolution)\n                               .filter(f => {\n                                 const fileBitrate = (f.size / this.videoDuration)\n                                 let threshold = fileBitrate\n\n                                 // If this is for a higher resolution or an initial load: add a margin\n                                 if (!this.currentVideoFile || f.resolution.id > this.currentVideoFile.resolution.id) {\n                                   threshold += ((fileBitrate * this.CONSTANTS.AUTO_QUALITY_THRESHOLD_PERCENT) / 100)\n                                 }\n\n                                 return averageDownloadSpeed > threshold\n                               })\n\n    // If the download speed is too bad, return the lowest resolution we have\n    if (filteredFiles.length === 0) return videoFileMinByResolution(files)\n\n    return videoFileMaxByResolution(filteredFiles)\n  }\n\n  private getAndSaveActualDownloadSpeed () {\n    const start = Math.max(this.downloadSpeeds.length - this.CONSTANTS.BANDWIDTH_AVERAGE_NUMBER_OF_VALUES, 0)\n    const lastDownloadSpeeds = this.downloadSpeeds.slice(start, this.downloadSpeeds.length)\n    if (lastDownloadSpeeds.length === 0) return -1\n\n    const sum = lastDownloadSpeeds.reduce((a, b) => a + b)\n    const averageBandwidth = Math.round(sum / lastDownloadSpeeds.length)\n\n    // Save the average bandwidth for future use\n    saveAverageBandwidth(averageBandwidth)\n\n    return averageBandwidth\n  }\n\n  private initializePlayer () {\n    this.buildQualities()\n\n    if (this.autoplay) {\n      this.player.posterImage.hide()\n\n      return this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\n    }\n\n    // Proxy first play\n    const oldPlay = this.player.play.bind(this.player);\n    (this.player as any).play = () => {\n      this.player.addClass('vjs-has-big-play-button-clicked')\n      this.player.play = oldPlay\n\n      this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\n    }\n  }\n\n  private runAutoQualityScheduler () {\n    this.autoQualityInterval = setInterval(() => {\n\n      // Not initialized or in HTTP fallback\n      if (this.torrent === undefined || this.torrent === null) return\n      if (this.autoResolution === false) return\n      if (this.isAutoResolutionObservation === true) return\n\n      const file = this.getAppropriateFile()\n      let changeResolution = false\n      let changeResolutionDelay = 0\n\n      // Lower resolution\n      if (this.isPlayerWaiting() && file.resolution.id < this.currentVideoFile.resolution.id) {\n        changeResolution = true\n      } else if (file.resolution.id > this.currentVideoFile.resolution.id) { // Higher resolution\n        changeResolution = true\n        changeResolutionDelay = this.CONSTANTS.AUTO_QUALITY_HIGHER_RESOLUTION_DELAY\n      }\n\n      if (changeResolution === true) {\n        this.updateResolution(file.resolution.id, changeResolutionDelay)\n\n        // Wait some seconds in observation of our new resolution\n        this.isAutoResolutionObservation = true\n\n        this.qualityObservationTimer = setTimeout(() => {\n          this.isAutoResolutionObservation = false\n        }, this.CONSTANTS.AUTO_QUALITY_OBSERVATION_TIME)\n      }\n    }, this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\n  }\n\n  private isPlayerWaiting () {\n    return this.player && this.player.hasClass('vjs-waiting')\n  }\n\n  private runTorrentInfoScheduler () {\n    this.torrentInfoInterval = setInterval(() => {\n      \n\n      // Not initialized yet\n      if (this.torrent === undefined) return\n\n      // Http fallback\n      if (this.torrent === null) return this.player.trigger('p2pInfo', false)\n\n      // this.webtorrent.downloadSpeed because we need to take into account the potential old torrent too\n      if (this.webtorrent.downloadSpeed !== 0) this.downloadSpeeds.push(this.webtorrent.downloadSpeed)\n\n    \n\n      return this.player.trigger('p2pInfo', {\n        source: 'webtorrent',\n        http: {\n          downloadSpeed: 0,\n          uploadSpeed: 0,\n          downloaded: 0,\n          uploaded: 0\n        },\n        p2p: {\n          downloadSpeed: this.torrent.downloadSpeed,\n          numPeers: this.torrent.numPeers,\n          uploadSpeed: this.torrent.uploadSpeed,\n          downloaded: this.torrent.downloaded,\n          uploaded: this.torrent.uploaded\n        }\n      } as PlayerNetworkInfo)\n    }, this.CONSTANTS.INFO_SCHEDULER)\n  }\n\n  private fallbackToHttp (options: PlayOptions, done?: Function) {\n\n\n    const paused = this.player.paused()\n\n    this.disableAutoResolution(true)\n\n    this.flushVideoFile(this.currentVideoFile, true)\n    this.torrent = null\n\n    // Enable error display now this is our last fallback\n    this.player.one('error', () => this.enableErrorDisplay())\n\n    const httpUrl = this.currentVideoFile.fileUrl\n    this.player.src = this.savePlayerSrcFunction\n    this.player.src(httpUrl)\n\n    this.changeQuality()\n\n    // We changed the source, so reinit captions\n    this.player.trigger('sourcechange')\n\n    return this.tryToPlay(err => {\n\n      if (err && done) return done(err)\n\n      if (options.seek) this.seek(options.seek)\n      if (options.forcePlay === false && paused === true) {\n        console.log(\"PLAUSE\")\n        this.player.pause()\n      }\n\n      if (done) return done()\n    })\n  }\n\n  private handleError (err: Error | string) {\n    return this.player.trigger('customError', { err })\n  }\n\n  private enableErrorDisplay () {\n    this.player.addClass('vjs-error-display-enabled')\n  }\n\n  private disableErrorDisplay () {\n    this.player.removeClass('vjs-error-display-enabled')\n  }\n\n  private pickAverageVideoFile () {\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\n\n    return this.videoFiles[Math.floor(this.videoFiles.length / 2)]\n  }\n\n  private stopTorrent (torrent: WebTorrent.Torrent) {\n    torrent.pause()\n    // Pause does not remove actual peers (in particular the webseed peer)\n    torrent.removePeer(torrent[ 'ws' ])\n  }\n\n  private renderFileInFakeElement (file: WebTorrent.TorrentFile, delay: number) {\n    this.destroyingFakeRenderer = false\n\n    const fakeVideoElem = document.createElement('video')\n    renderVideo(file, fakeVideoElem, { autoplay: false, controls: false }, (err, renderer) => {\n      this.fakeRenderer = renderer\n\n      // The renderer returns an error when we destroy it, so skip them\n      if (this.destroyingFakeRenderer === false && err) {\n        console.error('Cannot render new torrent in fake video element.', err)\n      }\n\n      // Load the future file at the correct time (in delay MS - 2 seconds)\n      fakeVideoElem.currentTime = this.player.currentTime() + (delay - 2000)\n    })\n  }\n\n  private destroyFakeRenderer () {\n    if (this.fakeRenderer) {\n      this.destroyingFakeRenderer = true\n\n      if (this.fakeRenderer.destroy) {\n        try {\n          this.fakeRenderer.destroy()\n        } catch (err) {\n          console.log('Cannot destroy correctly fake renderer.', err)\n        }\n      }\n      this.fakeRenderer = undefined\n    }\n  }\n\n  private buildQualities () {\n    const qualityLevelsPayload = []\n\n    for (const file of this.videoFiles) {\n      const representation = {\n        id: file.resolution.id,\n        label: this.buildQualityLabel(file),\n        height: file.resolution.id,\n        _enabled: true\n      }\n\n      this.player.qualityLevels().addQualityLevel(representation)\n\n      qualityLevelsPayload.push({\n        id: representation.id,\n        label: representation.label,\n        selected: false\n      })\n    }\n\n    const payload: LoadedQualityData = {\n      qualitySwitchCallback: (d: any) => this.qualitySwitchCallback(d),\n      qualityData: {\n        video: qualityLevelsPayload\n      }\n    }\n    this.player.tech(true).trigger('loadedqualitydata', payload)\n  }\n\n  private buildQualityLabel (file: VideoFile) {\n    let label = file.resolution.label\n\n    if (file.fps && file.fps >= 50) {\n      label += file.fps\n    }\n\n    return label\n  }\n\n  private qualitySwitchCallback (id: number) {\n    if (id === -1) {\n      if (this.autoResolutionPossible === true) this.enableAutoResolution()\n      return\n    }\n\n    this.disableAutoResolution()\n    this.updateResolution(id)\n  }\n\n  private changeQuality () {\n    const resolutionId = this.currentVideoFile.resolution.id\n    const qualityLevels = this.player.qualityLevels()\n\n    /*if (resolutionId === -1) {\n      qualityLevels.selectedIndex = -1\n      return\n    }*/\n\n    for (let i = 0; i < qualityLevels.length; i++) {\n      const q = qualityLevels[i]\n      if (q.height === resolutionId) qualityLevels.selectedIndex_ = i\n    }\n  }\n}\n\nvideojs.registerPlugin('webtorrent', WebTorrentPlugin)\nexport { WebTorrentPlugin }\n","module.exports = require('stream-http')\n","module.exports = require('https-browserify')\n","// Does nothing. Used to shim out node.js modules\n// which are no-ops in the browser.\nexport const NOOP = 0\n","module.exports = require('stream-browserify')"],"names":["MediaElementWrapper","require","videostream","VIDEOSTREAM_EXTS","renderVideo","file","elem","opts","callback","Error","name","createReadStream","validateFile","extension","extname","toLowerCase","preparedElem","renderer","currentTime","indexOf","useVideostream","useMediaSource","err","prepareElem","addEventListener","onError","removeEventListener","onLoadStart","useVP9","codecs","getCodec","fallbackToMediaSource","wrapper","writable","createWriteStream","pipe","console","log","undefined","autoplay","play","renderMedia","ext","ChunkDatabase","dbname","version","stores","chunks","Dexie","ExpirationDatabase","databases","PeertubeChunkStore","chunkLength","pendingPut","memoryChunks","databaseName","torrent","infoHash","setMaxListeners","Number","length","Infinity","lastChunkLength","lastChunkIndex","Math","ceil","db","expirationDB","runCleaner","index","buf","cb","isLastChunk","this","nextTick","push","id","putBulkTimeout","setTimeout","__awaiter","processing","transaction","bulkPut","map","p","forEach","BUFFERING_PUT_MS","get","memoryChunk","process","result","Buffer","alloc","offset","len","slice","catch","error","destroy","clearTimeout","cleanerInterval","clearInterval","close","dropDatabase","checkExpiration","setInterval","CLEANER_INTERVAL_MS","databasesToDeleteInfo","put","expiration","Date","getTime","CLEANER_EXPIRATION_MS","now","where","below","toArray","databaseToDeleteInfo","dbToDelete","delete","val","EventEmitter","CacheChunkStore","WebTorrentPlugin","player","options","startTime","CONSTANTS","INFO_SCHEDULER","AUTO_QUALITY_SCHEDULER","AUTO_QUALITY_THRESHOLD_PERCENT","AUTO_QUALITY_OBSERVATION_TIME","AUTO_QUALITY_HIGHER_RESOLUTION_DELAY","BANDWIDTH_AVERAGE_NUMBER_OF_VALUES","webtorrent","WebTorrent","tracker","rtcConfig","getRtcConfig","dht","destroyingFakeRenderer","autoResolution","autoResolutionPossible","isAutoResolutionObservation","playerRefusedP2P","downloadSpeeds","timeToInt","getStoredP2PEnabled","videoFiles","videoDuration","savePlayerSrcFunction","src","playerElement","ready","options_","duration","initializePlayer","runTorrentInfoScheduler","one","runAutoQualitySchedulerTimer","runAutoQualityScheduler","addTorrentDelay","qualityObservationTimer","torrentInfoInterval","autoQualityInterval","flushVideoFile","currentVideoFile","destroyFakeRenderer","resolution","videoFile","done","savedAverageBandwidth","getAverageBandwidthInStore","getAppropriateFile","pickAverageVideoFile","magnetUri","disableErrorDisplay","oldPlaybackRate","playbackRate","previousVideoFile","isIOS","fallbackToHttp","addTorrent","changeQuality","trigger","auto","resolutionId","delay","isPaused","paused","bigPlayButton","hide","addClass","posterImage","show","removeClass","newVideoFile","find","f","forcePlay","seek","updateVideoFile","destroyRenderer","remove","getCurrentResolutionId","forbid","possible","magnetOrTorrentUrl","oldTorrent","torrentOptions","store","storeOpts","max","add","stopTorrent","renderFileInFakeElement","files","controls","tryToPlay","pause","on","message","newOptions","handleError","playPromise","then","time","handleTechSeeked_","averageDownloadSpeed","filter","progress","ended","getAndSaveActualDownloadSpeed","playerHeight","offsetHeight","maxResolution","i","filteredFiles","fileBitrate","size","threshold","videoFileMinByResolution","videoFileMaxByResolution","start","lastDownloadSpeeds","sum","reduce","a","b","averageBandwidth","round","saveAverageBandwidth","buildQualities","oldPlay","bind","changeResolution","changeResolutionDelay","isPlayerWaiting","updateResolution","hasClass","downloadSpeed","source","http","uploadSpeed","downloaded","uploaded","p2p","numPeers","disableAutoResolution","enableErrorDisplay","httpUrl","fileUrl","floor","removePeer","fakeVideoElem","document","createElement","fakeRenderer","qualityLevelsPayload","representation","label","buildQualityLabel","height","_enabled","qualityLevels","addQualityLevel","selected","payload","qualitySwitchCallback","d","qualityData","video","tech","fps","enableAutoResolution","selectedIndex_","videojs","module","exports","NOOP"],"sourceRoot":""}